//! Schreier-Sims algorithm for permutation groups
//!
//! Implements the Schreier-Sims algorithm for efficiently computing
//! a base and strong generating set (BSGS) for a permutation group, as well as
//! the so-called "sift algorithm" for group membership testing and order computation.

use crate::canonicalization::{Permutation, BSGS};
use std::collections::{HashSet, VecDeque};

/// Computes the orbit of a point under a set of generators
fn orbit(point: usize, generators: &[Permutation]) -> HashSet<usize> {
    let mut orbit = HashSet::new();
    let mut queue = VecDeque::new();
    orbit.insert(point);
    queue.push_back(point);

    while let Some(x) = queue.pop_front() {
        for g in generators {
            let y = g[x];
            if orbit.insert(y) {
                queue.push_back(y);
            }
        }
    }
    orbit
}

/// Schreier-Sims algorithm: computes a BSGS for the group generated by `generators`
pub fn schreier_sims(generators: &[Permutation], degree: usize) -> BSGS {
    let mut base = Vec::new();
    let mut strong_gens = generators.to_vec();
    let mut used_points = HashSet::new();

    // Find a base: pick points moved by the generators
    for i in 0..degree {
        if strong_gens.iter().any(|g| g[i] != i) {
            base.push(i);
            used_points.insert(i);
        }
    }
    if base.is_empty() {
        // Trivial group
        return BSGS {
            base: vec![],
            generators: vec![(0..degree).collect()],
        };
    }

    // Main Schreier-Sims loop
    let mut i = 0;
    while i < base.len() {
        let b = base[i];
        let orbit_set = orbit(b, &strong_gens);
        let mut schreier_gens = Vec::new();

        for &alpha in &orbit_set {
            for g in &strong_gens {
                let beta = g[alpha];
                if !orbit_set.contains(&beta) {
                    // Schreier generator
                    let mut h = (0..degree).collect::<Vec<_>>();
                    let tmp = 0..degree;
                    for j in tmp {
                        h[j] = g[j];
                    }
                    schreier_gens.push(h);
                }
            }
        }
        for h in schreier_gens {
            if !strong_gens.contains(&h) {
                strong_gens.push(h);
            }
        }
        i += 1;
    }

    BSGS {
        base,
        generators: strong_gens,
    }
}

/// Sift algorithm for membership testing in a permutation group given by BSGS
/// Returns true if perm is in the group, false otherwise
pub fn is_member(perm: &Permutation, bsgs: &BSGS) -> bool {
    let n = perm.len();
    let mut h = perm.clone();
    let id: Permutation = (0..n).collect();
    let base = &bsgs.base;
    let strong_gens = &bsgs.generators;

    // For each base point, try to reduce h by right multiplying by a transversal
    for &beta in base {
        // Compute the orbit and Schreier tree for this base point
        let (orbit, schreier_tree) = schreier_orbit_tree(beta, strong_gens, n);
        let gamma = h[beta];
        if !orbit.contains(&gamma) {
            return false; // Not in the orbit, so not in the group
        }
        // Find the word (as a permutation) that maps beta to gamma in the Schreier tree
        let u_gamma = schreier_coset_representative(beta, gamma, &schreier_tree);
        // Right multiply h by the inverse of u_gamma
        let u_gamma_inv = inverse_permutation(&u_gamma);
        h = compose_permutations(&h, &u_gamma_inv);
    }
    h == id
}

/// Compute the orbit of a point and the Schreier tree (parent map)
fn schreier_orbit_tree(
    point: usize,
    generators: &[Permutation],
    degree: usize,
) -> (Vec<usize>, Vec<Option<(usize, Permutation)>>) {
    let mut orbit = Vec::new();
    let mut schreier_tree = vec![None; degree];
    let mut visited = vec![false; degree];
    let mut queue = VecDeque::new();
    orbit.push(point);
    visited[point] = true;
    queue.push_back(point);
    while let Some(x) = queue.pop_front() {
        for g in generators {
            let y = g[x];
            if !visited[y] {
                visited[y] = true;
                orbit.push(y);
                // Store parent and generator used
                schreier_tree[y] = Some((x, g.clone()));
                queue.push_back(y);
            }
        }
    }
    (orbit, schreier_tree)
}

/// Recover the coset representative (as a permutation) from Schreier tree
fn schreier_coset_representative(
    root: usize,
    target: usize,
    schreier_tree: &[Option<(usize, Permutation)>],
) -> Permutation {
    let mut path = Vec::new();
    let mut current = target;
    while current != root {
        if let Some((parent, gen)) = &schreier_tree[current] {
            path.push(gen.clone());
            current = *parent;
        } else {
            break; // Should not happen if target is in the orbit
        }
    }
    // Compose the path in reverse order
    let mut rep: Permutation = (0..schreier_tree.len()).collect();
    for g in path.iter().rev() {
        rep = compose_permutations(&rep, g);
    }
    rep
}

/// Compute the inverse of a permutation
fn inverse_permutation(perm: &Permutation) -> Permutation {
    let mut inv = vec![0; perm.len()];
    for (i, &p) in perm.iter().enumerate() {
        inv[p] = i;
    }
    inv
}

/// Composes two permutations (applies first, then second)
pub fn compose_permutations(perm1: &[usize], perm2: &[usize]) -> Permutation {
    let size = perm1.len().max(perm2.len());
    let mut result = vec![0; size];
    for i in 0..size {
        let intermediate = if i < perm1.len() { perm1[i] } else { i };
        result[i] = if intermediate < perm2.len() {
            perm2[intermediate]
        } else {
            intermediate
        };
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_orbit() {
        let gens = vec![vec![1, 0, 2]]; // swap 0 and 1
        let orb = orbit(0, &gens);
        assert!(orb.contains(&0));
        assert!(orb.contains(&1));
        assert!(!orb.contains(&2));
    }

    #[test]
    fn test_schreier_sims_trivial() {
        let gens: Vec<Permutation> = vec![];
        let bsgs = schreier_sims(&gens, 3);
        assert_eq!(bsgs.generators.len(), 1);
        assert_eq!(bsgs.base.len(), 0);
    }

    #[test]
    fn test_schreier_sims_simple() {
        let gens = vec![vec![1, 0, 2]]; // S_2 on 0,1
        let bsgs = schreier_sims(&gens, 3);
        assert!(bsgs.generators.iter().any(|g| g == &vec![1, 0, 2]));
        assert!(bsgs.base.contains(&0));
    }

    #[test]
    fn test_compose_permutations() {
        let perm1 = vec![1, 0, 2];
        let perm2 = vec![0, 2, 1];
        let composed = compose_permutations(&perm1, &perm2);
        assert_eq!(composed, vec![2, 0, 1]);
    }

    #[test]
    fn test_permutation_composition() {
        let perm1 = vec![1, 0, 2, 3];
        let perm2 = vec![0, 1, 3, 2];
        let composed = compose_permutations(&perm1, &perm2);

        // Apply perm1 first: [1,0,2,3], then perm2: [0,1,3,2]
        // Result should map 0->1->1, 1->0->0, 2->2->3, 3->3->2
        assert_eq!(composed, vec![1, 0, 3, 2]);
    }

    #[test]
    fn test_is_member() {
        let gens = vec![vec![1, 0, 2]];
        let bsgs = schreier_sims(&gens, 3);
        let id = vec![0, 1, 2];
        let swap = vec![1, 0, 2];
        assert!(is_member(&id, &bsgs));
        assert!(is_member(&swap, &bsgs));
        let not_in_group = vec![2, 1, 0];
        assert!(!is_member(&not_in_group, &bsgs));
    }
}
