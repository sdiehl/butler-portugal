//! Schreier-Sims algorithm for permutation groups
//!
//! Implements the Schreier-Sims algorithm for efficiently computing
//! a base and strong generating set (BSGS) for a permutation group, as well as
//! group membership testing and order computation.

use crate::canonicalization::{Permutation, BSGS};
use std::collections::{HashSet, VecDeque};

/// Computes the orbit of a point under a set of generators
fn orbit(point: usize, generators: &[Permutation]) -> HashSet<usize> {
    let mut orbit = HashSet::new();
    let mut queue = VecDeque::new();
    orbit.insert(point);
    queue.push_back(point);

    while let Some(x) = queue.pop_front() {
        for g in generators {
            let y = g[x];
            if orbit.insert(y) {
                queue.push_back(y);
            }
        }
    }
    orbit
}

/// Schreier-Sims algorithm: computes a BSGS for the group generated by `generators`
pub fn schreier_sims(generators: &[Permutation], degree: usize) -> BSGS {
    let mut base = Vec::new();
    let mut strong_gens = generators.to_vec();
    let mut used_points = HashSet::new();

    // Find a base: pick points moved by the generators
    for i in 0..degree {
        if strong_gens.iter().any(|g| g[i] != i) {
            base.push(i);
            used_points.insert(i);
        }
    }
    if base.is_empty() {
        // Trivial group
        return BSGS {
            base: vec![],
            generators: vec![(0..degree).collect()],
        };
    }

    // Main Schreier-Sims loop
    let mut i = 0;
    while i < base.len() {
        let b = base[i];
        let orbit_set = orbit(b, &strong_gens);
        let mut schreier_gens = Vec::new();

        for &alpha in &orbit_set {
            for g in &strong_gens {
                let beta = g[alpha];
                if !orbit_set.contains(&beta) {
                    // Schreier generator
                    let mut h = (0..degree).collect::<Vec<_>>();
                    let tmp = 0..degree;
                    for j in tmp {
                        h[j] = g[j];
                    }
                    schreier_gens.push(h);
                }
            }
        }
        for h in schreier_gens {
            if !strong_gens.contains(&h) {
                strong_gens.push(h);
            }
        }
        i += 1;
    }

    BSGS {
        base,
        generators: strong_gens,
    }
}

/// Checks if a permutation is in the group generated by the BSGS
pub fn is_member(perm: &Permutation, bsgs: &BSGS) -> bool {
    // Naive membership test: check if perm can be written as a product of generators
    // XXX: implement the sift algorithm
    let mut current = perm.clone();
    let id: Permutation = (0..perm.len()).collect();
    let mut limit = 10000; // Prevent infinite loops
    while current != id && limit > 0 {
        let mut changed = false;
        for g in &bsgs.generators {
            let composed = compose_permutations(&current, g);
            if composed < current {
                current = composed;
                changed = true;
                break;
            }
        }
        if !changed {
            break;
        }
        limit -= 1;
    }
    current == id
}

/// Composes two permutations (applies first, then second)
pub fn compose_permutations(perm1: &[usize], perm2: &[usize]) -> Permutation {
    let size = perm1.len().max(perm2.len());
    let mut result = vec![0; size];
    for i in 0..size {
        let intermediate = if i < perm1.len() { perm1[i] } else { i };
        result[i] = if intermediate < perm2.len() {
            perm2[intermediate]
        } else {
            intermediate
        };
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_orbit() {
        let gens = vec![vec![1, 0, 2]]; // swap 0 and 1
        let orb = orbit(0, &gens);
        assert!(orb.contains(&0));
        assert!(orb.contains(&1));
        assert!(!orb.contains(&2));
    }

    #[test]
    fn test_schreier_sims_trivial() {
        let gens: Vec<Permutation> = vec![];
        let bsgs = schreier_sims(&gens, 3);
        assert_eq!(bsgs.generators.len(), 1);
        assert_eq!(bsgs.base.len(), 0);
    }

    #[test]
    fn test_schreier_sims_simple() {
        let gens = vec![vec![1, 0, 2]]; // S_2 on 0,1
        let bsgs = schreier_sims(&gens, 3);
        assert!(bsgs.generators.iter().any(|g| g == &vec![1, 0, 2]));
        assert!(bsgs.base.contains(&0));
    }

    #[test]
    fn test_compose_permutations() {
        let perm1 = vec![1, 0, 2];
        let perm2 = vec![0, 2, 1];
        let composed = compose_permutations(&perm1, &perm2);
        assert_eq!(composed, vec![2, 0, 1]);
    }

    #[test]
    fn test_permutation_composition() {
        let perm1 = vec![1, 0, 2, 3];
        let perm2 = vec![0, 1, 3, 2];
        let composed = compose_permutations(&perm1, &perm2);
 
        // Apply perm1 first: [1,0,2,3], then perm2: [0,1,3,2]
        // Result should map 0->1->1, 1->0->0, 2->2->3, 3->3->2
        assert_eq!(composed, vec![1, 0, 3, 2]);
     }

    #[test]
    fn test_is_member() {
        let gens = vec![vec![1, 0, 2]];
        let bsgs = schreier_sims(&gens, 3);
        let id = vec![0, 1, 2];
        let swap = vec![1, 0, 2];
        assert!(is_member(&id, &bsgs));
        assert!(is_member(&swap, &bsgs));
        let not_in_group = vec![2, 1, 0];
        assert!(!is_member(&not_in_group, &bsgs));
    }
}
